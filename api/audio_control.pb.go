// Code generated by protoc-gen-go.
// source: audio_control.proto
// DO NOT EDIT!

package api

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type AudioClassifierMessage_ClassifierType int32

const (
	AudioClassifierMessage_LINEARSVM AudioClassifierMessage_ClassifierType = 0
)

var AudioClassifierMessage_ClassifierType_name = map[int32]string{
	0: "LINEARSVM",
}
var AudioClassifierMessage_ClassifierType_value = map[string]int32{
	"LINEARSVM": 0,
}

func (x AudioClassifierMessage_ClassifierType) Enum() *AudioClassifierMessage_ClassifierType {
	p := new(AudioClassifierMessage_ClassifierType)
	*p = x
	return p
}
func (x AudioClassifierMessage_ClassifierType) String() string {
	return proto.EnumName(AudioClassifierMessage_ClassifierType_name, int32(x))
}
func (x *AudioClassifierMessage_ClassifierType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(AudioClassifierMessage_ClassifierType_value, data, "AudioClassifierMessage_ClassifierType")
	if err != nil {
		return err
	}
	*x = AudioClassifierMessage_ClassifierType(value)
	return nil
}
func (AudioClassifierMessage_ClassifierType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor4, []int{0, 0}
}

// turn on/off audio capture
type AudioControl_AudioCaptureAction int32

const (
	AudioControl_OFF AudioControl_AudioCaptureAction = 0
	AudioControl_ON  AudioControl_AudioCaptureAction = 1
)

var AudioControl_AudioCaptureAction_name = map[int32]string{
	0: "OFF",
	1: "ON",
}
var AudioControl_AudioCaptureAction_value = map[string]int32{
	"OFF": 0,
	"ON":  1,
}

func (x AudioControl_AudioCaptureAction) Enum() *AudioControl_AudioCaptureAction {
	p := new(AudioControl_AudioCaptureAction)
	*p = x
	return p
}
func (x AudioControl_AudioCaptureAction) String() string {
	return proto.EnumName(AudioControl_AudioCaptureAction_name, int32(x))
}
func (x *AudioControl_AudioCaptureAction) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(AudioControl_AudioCaptureAction_value, data, "AudioControl_AudioCaptureAction")
	if err != nil {
		return err
	}
	*x = AudioControl_AudioCaptureAction(value)
	return nil
}
func (AudioControl_AudioCaptureAction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor4, []int{1, 0}
}

type AudioClassifierMessage struct {
	Idata            []int32                                `protobuf:"zigzag32,1,rep,name=idata" json:"idata,omitempty"`
	Numclasses       *int32                                 `protobuf:"varint,2,opt,name=numclasses" json:"numclasses,omitempty"`
	Type             *AudioClassifierMessage_ClassifierType `protobuf:"varint,3,opt,name=type,enum=AudioClassifierMessage_ClassifierType" json:"type,omitempty"`
	XXX_unrecognized []byte                                 `json:"-"`
}

func (m *AudioClassifierMessage) Reset()                    { *m = AudioClassifierMessage{} }
func (m *AudioClassifierMessage) String() string            { return proto.CompactTextString(m) }
func (*AudioClassifierMessage) ProtoMessage()               {}
func (*AudioClassifierMessage) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{0} }

func (m *AudioClassifierMessage) GetIdata() []int32 {
	if m != nil {
		return m.Idata
	}
	return nil
}

func (m *AudioClassifierMessage) GetNumclasses() int32 {
	if m != nil && m.Numclasses != nil {
		return *m.Numclasses
	}
	return 0
}

func (m *AudioClassifierMessage) GetType() AudioClassifierMessage_ClassifierType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return AudioClassifierMessage_LINEARSVM
}

type AudioControl struct {
	// minimum log2 audio energy above background noise to save off and classify.
	// 500 is a good value for this.  Raise to 1000 to be less sensitive.
	AudioMinEnergyThreshold *int32 `protobuf:"varint,1,opt,name=audio_min_energy_threshold" json:"audio_min_energy_threshold,omitempty"`
	// feature vectors come in every 32ms  ( 256 / 16000Hz * 2, where the "2" is for the average 2, decimate)
	// so every 1875 feat vecs is a minute.
	AudioNumFeatVecsUntilAttemptFeatureUpload *int32 `protobuf:"varint,2,opt,name=audio_num_feat_vecs_until_attempt_feature_upload" json:"audio_num_feat_vecs_until_attempt_feature_upload,omitempty"`
	// buffer size in bytes of audio features.  Note every ~330 bytes is 32 feat vecs, ergo 1 minute is about 20K
	// the buffer should be sized for your upload period
	AudioFeatBufferSize *int32 `protobuf:"varint,3,opt,name=audio_feat_buffer_size" json:"audio_feat_buffer_size,omitempty"`
	// frames are 16ms long (256/16000).  When you detect snoring (or whatever), this is how many frames of data you want to record
	AudioRecordingPeriodInFrames *int32                           `protobuf:"varint,4,opt,name=audio_recording_period_in_frames" json:"audio_recording_period_in_frames,omitempty"`
	AudioCaptureAction           *AudioControl_AudioCaptureAction `protobuf:"varint,8,opt,name=audio_capture_action,enum=AudioControl_AudioCaptureAction" json:"audio_capture_action,omitempty"`
	AudioCaptureClassifier       *AudioClassifierMessage          `protobuf:"bytes,9,opt,name=audio_capture_classifier" json:"audio_capture_classifier,omitempty"`
	AudioCaptureHmm              *AudioClassifierMessage          `protobuf:"bytes,10,opt,name=audio_capture_hmm" json:"audio_capture_hmm,omitempty"`
	AudioSaveRawData             *AudioControl_AudioCaptureAction `protobuf:"varint,11,opt,name=audio_save_raw_data,enum=AudioControl_AudioCaptureAction" json:"audio_save_raw_data,omitempty"`
	AudioSaveFeatures            *AudioControl_AudioCaptureAction `protobuf:"varint,12,opt,name=audio_save_features,enum=AudioControl_AudioCaptureAction" json:"audio_save_features,omitempty"`
	XXX_unrecognized             []byte                           `json:"-"`
}

func (m *AudioControl) Reset()                    { *m = AudioControl{} }
func (m *AudioControl) String() string            { return proto.CompactTextString(m) }
func (*AudioControl) ProtoMessage()               {}
func (*AudioControl) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{1} }

func (m *AudioControl) GetAudioMinEnergyThreshold() int32 {
	if m != nil && m.AudioMinEnergyThreshold != nil {
		return *m.AudioMinEnergyThreshold
	}
	return 0
}

func (m *AudioControl) GetAudioNumFeatVecsUntilAttemptFeatureUpload() int32 {
	if m != nil && m.AudioNumFeatVecsUntilAttemptFeatureUpload != nil {
		return *m.AudioNumFeatVecsUntilAttemptFeatureUpload
	}
	return 0
}

func (m *AudioControl) GetAudioFeatBufferSize() int32 {
	if m != nil && m.AudioFeatBufferSize != nil {
		return *m.AudioFeatBufferSize
	}
	return 0
}

func (m *AudioControl) GetAudioRecordingPeriodInFrames() int32 {
	if m != nil && m.AudioRecordingPeriodInFrames != nil {
		return *m.AudioRecordingPeriodInFrames
	}
	return 0
}

func (m *AudioControl) GetAudioCaptureAction() AudioControl_AudioCaptureAction {
	if m != nil && m.AudioCaptureAction != nil {
		return *m.AudioCaptureAction
	}
	return AudioControl_OFF
}

func (m *AudioControl) GetAudioCaptureClassifier() *AudioClassifierMessage {
	if m != nil {
		return m.AudioCaptureClassifier
	}
	return nil
}

func (m *AudioControl) GetAudioCaptureHmm() *AudioClassifierMessage {
	if m != nil {
		return m.AudioCaptureHmm
	}
	return nil
}

func (m *AudioControl) GetAudioSaveRawData() AudioControl_AudioCaptureAction {
	if m != nil && m.AudioSaveRawData != nil {
		return *m.AudioSaveRawData
	}
	return AudioControl_OFF
}

func (m *AudioControl) GetAudioSaveFeatures() AudioControl_AudioCaptureAction {
	if m != nil && m.AudioSaveFeatures != nil {
		return *m.AudioSaveFeatures
	}
	return AudioControl_OFF
}

func init() {
	proto.RegisterType((*AudioClassifierMessage)(nil), "AudioClassifierMessage")
	proto.RegisterType((*AudioControl)(nil), "AudioControl")
	proto.RegisterEnum("AudioClassifierMessage_ClassifierType", AudioClassifierMessage_ClassifierType_name, AudioClassifierMessage_ClassifierType_value)
	proto.RegisterEnum("AudioControl_AudioCaptureAction", AudioControl_AudioCaptureAction_name, AudioControl_AudioCaptureAction_value)
}

var fileDescriptor4 = []byte{
	// 411 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x8c, 0x52, 0x4f, 0x6b, 0x14, 0x31,
	0x14, 0xef, 0x76, 0x77, 0xd5, 0xbe, 0xd6, 0xb2, 0x8d, 0x52, 0x43, 0x0f, 0xba, 0x0c, 0x28, 0x7b,
	0x0a, 0xb2, 0x28, 0xe8, 0x41, 0x61, 0x2b, 0x16, 0x04, 0xdb, 0x8a, 0x8a, 0x07, 0x2f, 0x21, 0xce,
	0xbc, 0xd9, 0x09, 0xcc, 0x4c, 0x42, 0xfe, 0x54, 0xea, 0x47, 0xf0, 0xe8, 0x27, 0x36, 0x93, 0x8c,
	0xda, 0x81, 0x5a, 0xf6, 0x98, 0x97, 0xdf, 0xbf, 0xf7, 0x4b, 0xe0, 0x9e, 0xf0, 0x85, 0x54, 0x3c,
	0x57, 0xad, 0x33, 0xaa, 0x66, 0xda, 0x28, 0xa7, 0xb2, 0x5f, 0x23, 0x38, 0x5c, 0x75, 0xf3, 0x37,
	0xb5, 0xb0, 0x56, 0x96, 0x12, 0xcd, 0x29, 0x5a, 0x2b, 0xd6, 0x48, 0xee, 0xc2, 0x54, 0x16, 0xc2,
	0x09, 0x3a, 0x9a, 0x8f, 0x17, 0x07, 0x84, 0x00, 0xb4, 0xbe, 0xc9, 0x3b, 0x18, 0x5a, 0xba, 0x3d,
	0x1f, 0x2d, 0xa6, 0xe4, 0x19, 0x4c, 0xdc, 0xa5, 0x46, 0x3a, 0x0e, 0xa7, 0xfd, 0xe5, 0x13, 0x76,
	0xbd, 0x12, 0xfb, 0x37, 0xf9, 0x1c, 0xd0, 0xd9, 0x23, 0xd8, 0x1f, 0x4e, 0x82, 0xd5, 0xce, 0xfb,
	0x77, 0x67, 0x6f, 0x57, 0x1f, 0x3f, 0x7d, 0x39, 0x9d, 0x6d, 0x65, 0x3f, 0x27, 0xb0, 0x97, 0xa4,
	0x52, 0x56, 0x92, 0xc1, 0x51, 0x0a, 0xdf, 0xc8, 0x96, 0x63, 0x8b, 0x66, 0x7d, 0xc9, 0x5d, 0x65,
	0xd0, 0x56, 0xaa, 0x2e, 0x42, 0xbe, 0x2e, 0xcb, 0x0b, 0x78, 0x9a, 0x30, 0x21, 0x25, 0x2f, 0x51,
	0x38, 0x7e, 0x81, 0xb9, 0xe5, 0xbe, 0x75, 0xb2, 0xe6, 0xc2, 0x39, 0x6c, 0xb4, 0x8b, 0x73, 0x6f,
	0x90, 0x7b, 0x5d, 0x2b, 0x51, 0xf4, 0x5b, 0x3c, 0x84, 0xc3, 0xc4, 0x8c, 0xac, 0x6f, 0xbe, 0x2c,
	0xd1, 0x70, 0x2b, 0x7f, 0xa4, 0xbd, 0xa6, 0x64, 0x01, 0xf3, 0x74, 0x6f, 0x30, 0x57, 0xa6, 0x90,
	0xed, 0x9a, 0x6b, 0x34, 0x52, 0x15, 0x3c, 0xa4, 0x29, 0x8d, 0x68, 0x42, 0x1f, 0x93, 0x88, 0x7c,
	0x0d, 0xf7, 0xfb, 0x92, 0x85, 0x8e, 0x3e, 0x22, 0x77, 0x52, 0xb5, 0xf4, 0x4e, 0xec, 0x67, 0xce,
	0xae, 0x2e, 0xd5, 0x1f, 0x12, 0x70, 0x15, 0x71, 0xe4, 0x25, 0xd0, 0x21, 0x3f, 0xff, 0xdb, 0x13,
	0xdd, 0x09, 0x1a, 0xbb, 0xcb, 0x07, 0xff, 0xe9, 0x98, 0x2c, 0xe1, 0x60, 0x48, 0xad, 0x9a, 0x86,
	0xc2, 0xcd, 0x9c, 0x57, 0x7f, 0xfe, 0x84, 0x15, 0x17, 0xc8, 0x8d, 0xf8, 0xce, 0xe3, 0x7b, 0xef,
	0x6e, 0x98, 0x76, 0x48, 0xef, 0xab, 0xb5, 0x74, 0x6f, 0x33, 0x7a, 0xf6, 0x18, 0xc8, 0x35, 0xa2,
	0xb7, 0x61, 0x7c, 0x7e, 0x72, 0x32, 0xdb, 0x22, 0xb7, 0x60, 0xfb, 0xfc, 0x6c, 0x36, 0x3a, 0x7e,
	0x0e, 0x47, 0xb9, 0x6a, 0x58, 0x85, 0x75, 0xad, 0x98, 0xf5, 0x46, 0x6a, 0xcf, 0x84, 0x96, 0x2c,
	0x5a, 0x1f, 0x93, 0xab, 0x2e, 0x1f, 0xba, 0x2f, 0x6d, 0xbf, 0x8e, 0xc3, 0xf5, 0xef, 0x00, 0x00,
	0x00, 0xff, 0xff, 0x34, 0x6a, 0x67, 0x03, 0xee, 0x02, 0x00, 0x00,
}
